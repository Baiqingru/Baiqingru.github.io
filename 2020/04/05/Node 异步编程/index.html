<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="虚怀若谷才能逆水行舟"><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.5"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.5"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><title>Node 异步编程 | CodeHare的博客</title><meta name="generator" content="Hexo 4.2.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Node 异步编程</h1><a id="logo" href="/.">CodeHare的博客</a><p class="description"> Stay Hungry , Stay Foolish </p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">Node 异步编程</h1><div class="post-meta"><a href="/2020/04/05/Node%20%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/#comments" class="comment-count"></a><p><span class="date">Apr 05, 2020</span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><h2 id="node-js-异步编程"><a href="#node-js-异步编程" class="headerlink" title="node.js 异步编程"></a>node.js 异步编程</h2><h3 id="1-服务器端基本概念"><a href="#1-服务器端基本概念" class="headerlink" title="1.服务器端基本概念"></a>1.服务器端基本概念</h3><h4 id="1-1-网站的组成"><a href="#1-1-网站的组成" class="headerlink" title="1.1 网站的组成"></a>1.1 网站的组成</h4><ul>
<li>网站应用程序主要分为两大部分：客户端和服务器端。</li>
<li>客户端：在浏览器中运行的部分，就是用户看到并与之交互的界面程序。使用HTML、CSS、JavaScript构建。</li>
<li>服务器端：在服务器中运行的部分，负责存储数据和处理应用逻辑。<ul>
<li>node网站服务器 : 能够提供网站访问服务的机器就是网站服务器，能够接收客户端的请求，能够对请求做出响应。</li>
</ul>
</li>
</ul>
<h4 id="1-2-URL"><a href="#1-2-URL" class="headerlink" title="1.2 URL"></a>1.2 URL</h4><ul>
<li>统一资源定位符 (就是网页地址)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">	&lt;https:&#x2F;&#x2F;www.baidu.com&#x2F;?tn&#x3D;78000241_11_hao_pg&gt;</span><br><span class="line">&#x2F;&#x2F;传输协议 &#x2F;&#x2F;域名:端口(服务器的Ip) &#x2F;&#x2F; 资源所在位置标识符</span><br></pre></td></tr></table></figure>

<ul>
<li>http : 超文本传输协议 , 提供一种发布和接收HTM页面的方法</li>
</ul>
<h4 id="1-3-客户端与服务器端"><a href="#1-3-客户端与服务器端" class="headerlink" title="1.3 客户端与服务器端"></a>1.3 客户端与服务器端</h4><ul>
<li><p>开发后阶段 , <strong>客户端(浏览器)</strong>及<strong>服务器端(Node)</strong>使用同一电脑</p>
<ul>
<li><p>本机域名 : localhost</p>
<ul>
<li>域名就是平时上网所使用的网址<br><strong><em>虽然在地址栏中输入的是网址, 但是最终还是会将域名转换为 IP才能访问到指定的网站服务器。</em></strong></li>
</ul>
</li>
<li><p>本地 Ip :  127.0.0.1</p>
<ul>
<li>IP (Internet Protocol Address)地址 : 互联网中设备的唯一标识,代表互联网协议地址.</li>
</ul>
<p>补充 : 端口是计算机与外界通讯交流的出口，用来区分服务器电脑中提供的不同的服务</p>
</li>
</ul>
</li>
</ul>
<h3 id="2-创建web服务器"><a href="#2-创建web服务器" class="headerlink" title="2.创建web服务器"></a>2.创建web服务器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 1.引入系统模块http</span><br><span class="line">&#x2F;&#x2F; 2.创建网站服务器</span><br><span class="line">&#x2F;&#x2F; 3.为网站服务器对象添加请求事件</span><br><span class="line">&#x2F;&#x2F; 4.实现路由功能</span><br><span class="line">&#x2F;&#x2F; 	1.获取客户端的请求方式</span><br><span class="line">&#x2F;&#x2F; 	2.获取客户端的请求地址</span><br><span class="line">const http &#x3D; require(&#39;http&#39;);</span><br><span class="line">const url &#x3D; require(&#39;url&#39;);</span><br><span class="line"></span><br><span class="line">const app &#x3D; http.createServer();</span><br><span class="line"></span><br><span class="line">app.on(&#39;request&#39;, (req, res) &#x3D;&gt; &#123;</span><br><span class="line">	&#x2F;&#x2F; 获取请求方式</span><br><span class="line">	const method &#x3D; req.method.toLowerCase();</span><br><span class="line">	&#x2F;&#x2F; 获取请求地址</span><br><span class="line">	const pathname &#x3D; url.parse(req.url).pathname;</span><br><span class="line"></span><br><span class="line">	res.writeHead(200, &#123;</span><br><span class="line">		&#39;content-type&#39;: &#39;text&#x2F;html;charset&#x3D;utf8&#39;</span><br><span class="line">	&#125;);</span><br><span class="line"></span><br><span class="line">	if (method &#x3D;&#x3D; &#39;get&#39;) &#123;</span><br><span class="line"></span><br><span class="line">		if (pathname &#x3D;&#x3D; &#39;&#x2F;&#39; || pathname &#x3D;&#x3D; &#39;&#x2F;index&#39;) &#123;</span><br><span class="line">			res.end(&#39;欢迎来到首页&#39;)</span><br><span class="line">		&#125;else if (pathname &#x3D;&#x3D; &#39;&#x2F;list&#39;) &#123;</span><br><span class="line">			res.end(&#39;欢迎来到列表页&#39;)</span><br><span class="line">		&#125;else &#123;</span><br><span class="line">			res.end(&#39;您访问的页面不存在&#39;)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;else if (method &#x3D;&#x3D; &#39;post&#39;) &#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(3000);</span><br><span class="line">console.log(&#39;服务器启动成功&#39;);</span><br></pre></td></tr></table></figure>

<p>完整案例: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 用于创建网站服务器的模块</span><br><span class="line">const http &#x3D; require(&#39;http&#39;);</span><br><span class="line">&#x2F;&#x2F; 用于处理url地址</span><br><span class="line">const url &#x3D; require(&#39;url&#39;);</span><br><span class="line">&#x2F;&#x2F; app对象就是网站服务器对象</span><br><span class="line">const app &#x3D; http.createServer();</span><br><span class="line">&#x2F;&#x2F; 当客户端有请求来的时候</span><br><span class="line">app.on(&#39;request&#39;, (req, res) &#x3D;&gt; &#123;</span><br><span class="line">	&#x2F;&#x2F; 获取请求方式</span><br><span class="line">	&#x2F;&#x2F; req.method</span><br><span class="line">	&#x2F;&#x2F; console.log(req.method);</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 获取请求地址</span><br><span class="line">	&#x2F;&#x2F; req.url</span><br><span class="line">	&#x2F;&#x2F; console.log(req.url);</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 获取请求报文信息</span><br><span class="line">	&#x2F;&#x2F; req.headers</span><br><span class="line">	&#x2F;&#x2F; console.log(req.headers[&#39;accept&#39;]);</span><br><span class="line"></span><br><span class="line">	res.writeHead(200, &#123;</span><br><span class="line">		&#39;content-type&#39;: &#39;text&#x2F;html;charset&#x3D;utf8&#39;</span><br><span class="line">	&#125;);</span><br><span class="line"></span><br><span class="line">	console.log(req.url);</span><br><span class="line">	&#x2F;&#x2F; 1) 要解析的url地址</span><br><span class="line">	&#x2F;&#x2F; 2) 将查询参数解析成对象形式</span><br><span class="line">	let &#123;</span><br><span class="line">		query,</span><br><span class="line">		pathname</span><br><span class="line">	&#125; &#x3D; url.parse(req.url, true);</span><br><span class="line">	console.log(query.name)</span><br><span class="line">	console.log(query.age)</span><br><span class="line"></span><br><span class="line">	if (pathname &#x3D;&#x3D; &#39;&#x2F;index&#39; || pathname &#x3D;&#x3D; &#39;&#x2F;&#39;) &#123;</span><br><span class="line">		res.end(&#39;&lt;h2&gt;欢迎来到首页&lt;&#x2F;h2&gt;&#39;);</span><br><span class="line">	&#125; else if (pathname &#x3D;&#x3D; &#39;&#x2F;list&#39;) &#123;</span><br><span class="line">		res.end(&#39;welcome to listpage&#39;);</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		res.end(&#39;not found&#39;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (req.method &#x3D;&#x3D; &#39;POST&#39;) &#123;</span><br><span class="line">		res.end(&#39;post&#39;)</span><br><span class="line">	&#125; else if (req.method &#x3D;&#x3D; &#39;GET&#39;) &#123;</span><br><span class="line">		res.end(&#39;get&#39;)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; res.end(&#39;&lt;h2&gt;hello user&lt;&#x2F;h2&gt;&#39;);</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F; 监听端口</span><br><span class="line">app.listen(3000);</span><br><span class="line">console.log(&#39;网站服务器启动成功&#39;);</span><br></pre></td></tr></table></figure>

<h4 id="2-1-HTTP-协议"><a href="#2-1-HTTP-协议" class="headerlink" title="2.1 HTTP 协议"></a>2.1 HTTP 协议</h4><ul>
<li><h5 id="超文本传输协议-http"><a href="#超文本传输协议-http" class="headerlink" title="超文本传输协议 (http)"></a>超文本传输协议 (http)</h5><ul>
<li>规定了如何从网站服务器传输超文本到本地浏览器 ,    基于客户端服务器的架构工作, 是客户端与服务器(网站)请求和应答的标准。</li>
<li>图1    </li>
</ul>
</li>
<li><h5 id="报文"><a href="#报文" class="headerlink" title="报文"></a>报文</h5><ul>
<li><p>在HTTP请求响应过程中传递的数据块,包括传送的数据和附加信息, 并要遵守规定好的格式。</p>
</li>
<li><p>图2</p>
</li>
<li><p><strong>浏览器 → Network → Name → Headers (请求与响应的报文数据)</strong></p>
<ol>
<li><h6 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h6><ul>
<li>请求方式<ul>
<li>GET 请求数据<ul>
<li>在浏览器的地址栏直接输网址得到请求方式是 GET 方式 </li>
<li>浏览器的图标请求是浏览器自动发出的</li>
<li>表单的跳转是默认的GET值  &amp;  表单form的method默认值也为GET</li>
</ul>
</li>
<li>POST 发送数据 (相对安全)<ul>
<li>安全性高</li>
</ul>
</li>
<li>请求地址</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">app.on(&#39;request&#39;, (req, res) &#x3D;&gt; &#123;</span><br><span class="line">req.headers  &#x2F;&#x2F;获取请求报文信息</span><br><span class="line">req.headers[&#39;键的名字&#39;]  &#x2F;&#x2F;获取请求报文信息</span><br><span class="line">req.url  &#x2F;&#x2F;获取请求地址</span><br><span class="line">req.method  &#x2F;&#x2F;获取请求方法</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>form 表单</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;zh-CN&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line"> &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line"> &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0, maximum-scale&#x3D;1.0, minimum-scale&#x3D;1.0,user-scalable&#x3D;no&quot;&gt;</span><br><span class="line"> &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;ie&#x3D;edge&quot;&gt;</span><br><span class="line"> &lt;title&gt;Document&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"> &lt;!-- </span><br><span class="line">     method : 指定当前表单提交的方式</span><br><span class="line">     action : 指定当前表单提交的地址</span><br><span class="line">     form 默认表单提交方式为 GET </span><br><span class="line">  --&gt;</span><br><span class="line"> &lt;form method&#x3D;&quot;POST&quot; action&#x3D;&quot;http:&#x2F;&#x2F;localhost:4000&quot;&gt;</span><br><span class="line">     &lt;input type&#x3D;&quot;submit&quot; name&#x3D;&quot;&quot;&gt;</span><br><span class="line"> &lt;&#x2F;form&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<h6 id="2-响应报文"><a href="#2-响应报文" class="headerlink" title="2. 响应报文"></a>2. 响应报文</h6><ul>
<li>HTTP状态码<ul>
<li>200请求成功</li>
<li>404请求的资源没找到</li>
<li>500服务器端错误</li>
<li>400客户端请求有语法错误</li>
</ul>
</li>
<li>响应内容<ul>
<li>text/plain 纯文本</li>
<li>text/html</li>
<li>text/css</li>
<li>application/javascript</li>
<li>image/jpeg</li>
<li>application/json</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">响应头语法 :</span><br><span class="line">response.writeHead(statusCode, [reasonPhrase], [headers])</span><br><span class="line"></span><br><span class="line">接收参数：</span><br><span class="line">statusCode HTTP状态码</span><br><span class="line">reasonPhrase</span><br><span class="line">headers 类似关联数组的对象，表示响应头的每个属性</span><br></pre></td></tr></table></figure>

<h6 id="3-请求参数"><a href="#3-请求参数" class="headerlink" title="3.请求参数"></a>3.请求参数</h6><ul>
<li>GET请求参数<ul>
<li>参数被放置在浏览器地址栏中，例如：<a href="http://localhost:3000/?name=小白&amp;sex=man" target="_blank" rel="noopener">http://localhost:3000/?name=小白&amp;sex=man</a></li>
<li>get的请求参数在path资源路径的后面添加，以<code>?</code>表示参数的开始，以<code>key=value</code>表示参数的键值对，多个参数以<code>&amp;</code>符号分割</li>
<li>hash部分表示的是资源定位符（滚动网页可视区域），由浏览器自动解析处理，它的作用是跳转到对应id的标签的位置</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;1.导入模块</span><br><span class="line">const http &#x3D; require(&#39;http&#39;);</span><br><span class="line">&#x2F;&#x2F;url模块：解析url路径得到url协议中的每一部分</span><br><span class="line">const url &#x3D; require(&#39;url&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;2.创建服务器</span><br><span class="line">let server &#x3D; http.createServer((req,res)&#x3D;&gt;&#123;</span><br><span class="line"> &#x2F;&#x2F;req.url:获取整个请求url  包含路径和参数</span><br><span class="line"> console.log(req.url);</span><br><span class="line"> &#x2F;&#x2F;decodeURI():了解即可，默认情况下url中的中文会进行URI编码，使用decodeURI解码可以得到中文</span><br><span class="line"> console.log(decodeURI(req.url));</span><br><span class="line"></span><br><span class="line"> &#x2F;*1.使用url模块解析get请求 </span><br><span class="line"> 第一个参数：要解析的url</span><br><span class="line"> 第二个参数: 布尔类型  true：推荐使用，得到的参数是一个对象   false：得到参数是字符串</span><br><span class="line"> 返回值：对象类型：将url中的每一部分作为对象的属性</span><br><span class="line">  *&#x2F;</span><br><span class="line"> let urlObjc &#x3D; url.parse(req.url,true);</span><br><span class="line"> console.log(urlObjc);</span><br><span class="line"></span><br><span class="line"> &#x2F;&#x2F;2.获取请求的路径</span><br><span class="line"> let urlPath &#x3D; urlObjc.pathname;</span><br><span class="line"> console.log(urlPath);</span><br><span class="line"> &#x2F;&#x2F;3.获取请求的参数</span><br><span class="line"> let query &#x3D; urlObjc.query;</span><br><span class="line"> console.log(query);</span><br><span class="line"></span><br><span class="line"> &#x2F;&#x2F;响应客户端请求</span><br><span class="line"> &#x2F;&#x2F;服务端不能直接响应js对象，需要转成json对象（后台具有跨平台性，不是只为前端服务）</span><br><span class="line"> res.end(JSON.stringify(&#123;</span><br><span class="line">     code:10000,</span><br><span class="line">     list:[10,20,30]</span><br><span class="line"> &#125;));</span><br><span class="line">&#x2F;*</span><br><span class="line">&#123;</span><br><span class="line">protocol: null,&#x2F;&#x2F;协议名</span><br><span class="line">slashes: null,&#x2F;&#x2F;表示 &#x2F;&#x2F;到第一个&#x2F;之间都是host</span><br><span class="line">auth: null,&#x2F;&#x2F;认证</span><br><span class="line">host: null,&#x2F;&#x2F;主机名+ 端口号  hosetname+port</span><br><span class="line">port: null,&#x2F;&#x2F;端口号</span><br><span class="line">hostname: null,&#x2F;&#x2F;主机名  ip地址</span><br><span class="line">hash: null,&#x2F;&#x2F;资源定位符</span><br><span class="line">search: &#39;?name&#x3D;OldFe&amp;age&#x3D;18&#39;,</span><br><span class="line">query: &#123; name: &#39;OldFe&#39;, age: &#39;18&#39; &#125;,&#x2F;&#x2F;get请求的参数对象</span><br><span class="line">pathname: &#39;&#x2F;getRequest&#39;,&#x2F;&#x2F;路径</span><br><span class="line">path: &#39;&#x2F;getRequest?name&#x3D;OldFe&amp;age&#x3D;18&#39;,&#x2F;&#x2F;路径+请求参数</span><br><span class="line">href: &#39;&#x2F;getRequest?name&#x3D;OldFe&amp;age&#x3D;18&#39; &#125;</span><br><span class="line">*&#x2F;</span><br><span class="line">&#x2F;&#x2F;console.log(urlObjc);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;3.开启服务器</span><br><span class="line">server.listen(3000,()&#x3D;&gt;&#123;</span><br><span class="line"> console.log(&#39;success&#39;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>POST请求参数</p>
<ul>
<li>post请求的参数是在请求体中，无法使用get的方式来接收post请求的参数</li>
<li>post请求的参数无法一次获取，有可能是多次 原因：post可以提交大数据，而宽带有网络限制</li>
<li>获取POST参数需要使用data事件和end事件</li>
<li>使用querystring系统模块将参数转换为对象格式</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 导入系统模块querystring 用于将HTTP参数转换为对象格式</span><br><span class="line">const querystring &#x3D; require(&#39;querystring&#39;);</span><br><span class="line">app.on(&#39;request&#39;, (req, res) &#x3D;&gt; &#123;</span><br><span class="line">  let postData &#x3D; &#39;&#39;;</span><br><span class="line">  &#x2F;&#x2F; 监听参数传输事件</span><br><span class="line">  req.on(&#39;data&#39;, (chunk) &#x3D;&gt; postData +&#x3D; chunk;);</span><br><span class="line">  &#x2F;&#x2F; 监听参数传输完毕事件</span><br><span class="line">  req.on(&#39;end&#39;, () &#x3D;&gt; &#123; </span><br><span class="line">      console.log(querystring.parse(postData)); </span><br><span class="line">  &#125;); </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p> <strong>总结:</strong></p>
<ol>
<li>GET方式<ul>
<li>浏览器地址栏</li>
<li>link标签的href属性</li>
<li>script标签的src属性</li>
<li>img标签的src属性</li>
<li>Form表单提交</li>
</ul>
</li>
<li>POST方式<ul>
<li>Form表单提交</li>
</ul>
</li>
</ol>
<h4 id="2-2-路由"><a href="#2-2-路由" class="headerlink" title="2.2 路由"></a>2.2 路由</h4><ul>
<li>​    路由是指客户端请求地址与服务器端程序代码的对应关系。简单的说，就是请求什么响应什么。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">路由代码的实现 :</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 1.引入系统模块http</span><br><span class="line">&#x2F;&#x2F; 2.创建网站服务器</span><br><span class="line">&#x2F;&#x2F; 3.为网站服务器对象添加请求事件</span><br><span class="line">&#x2F;&#x2F; 4.实现路由功能</span><br><span class="line">&#x2F;&#x2F; 	1.获取客户端的请求方式</span><br><span class="line">&#x2F;&#x2F; 	2.获取客户端的请求地址</span><br><span class="line">const http &#x3D; require(&#39;http&#39;);</span><br><span class="line">const url &#x3D; require(&#39;url&#39;);</span><br><span class="line"></span><br><span class="line">const app &#x3D; http.createServer();</span><br><span class="line"></span><br><span class="line">app.on(&#39;request&#39;, (req, res) &#x3D;&gt; &#123;</span><br><span class="line">	&#x2F;&#x2F; 获取请求方式</span><br><span class="line">	&#x2F;&#x2F; towerCase 将GET 转换为小写的方法</span><br><span class="line">	const method &#x3D; req.method.toLowerCase();</span><br><span class="line">	&#x2F;&#x2F; 获取请求地址</span><br><span class="line">	const pathname &#x3D; url.parse(req.url).pathname;</span><br><span class="line"></span><br><span class="line">	res.writeHead(200, &#123;</span><br><span class="line">		&#39;content-type&#39;: &#39;text&#x2F;html;charset&#x3D;utf8&#39;</span><br><span class="line">	&#125;);</span><br><span class="line"></span><br><span class="line">	if (method &#x3D;&#x3D; &#39;get&#39;) &#123;</span><br><span class="line"></span><br><span class="line">		if (pathname &#x3D;&#x3D; &#39;&#x2F;&#39; || pathname &#x3D;&#x3D; &#39;&#x2F;index&#39;) &#123;</span><br><span class="line">			res.end(&#39;欢迎来到首页&#39;)</span><br><span class="line">		&#125;else if (pathname &#x3D;&#x3D; &#39;&#x2F;list&#39;) &#123;</span><br><span class="line">			res.end(&#39;欢迎来到列表页&#39;)</span><br><span class="line">		&#125;else &#123;</span><br><span class="line">			res.end(&#39;您访问的页面不存在&#39;)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;else if (method &#x3D;&#x3D; &#39;post&#39;) &#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(3000);</span><br><span class="line">console.log(&#39;服务器启动成功&#39;);</span><br></pre></td></tr></table></figure>

<h4 id="2-3-静态资源访问"><a href="#2-3-静态资源访问" class="headerlink" title="2.3 静态资源访问"></a>2.3 静态资源访问</h4><ul>
<li>静态资源：服务器端不需要处理，可以直接响应给客户端的资源就是静态资源，例如CSS、html 、JavaScript&amp;image文件。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">eg : http:&#x2F;&#x2F;www.baidu.cn&#x2F;images&#x2F;logo.png 此即静态资源</span><br><span class="line"></span><br><span class="line">代码：</span><br><span class="line">const http &#x3D; require(&#39;http&#39;);</span><br><span class="line">const url &#x3D; require(&#39;url&#39;);</span><br><span class="line">const path &#x3D; require(&#39;path&#39;);</span><br><span class="line">const fs &#x3D; require(&#39;fs&#39;);</span><br><span class="line">&#x2F;&#x2F; mime 会根据当前请求得到路径分析出请求资源的类型</span><br><span class="line">const mime &#x3D; require(&#39;mime&#39;);</span><br><span class="line"></span><br><span class="line">const app &#x3D; http.createServer();</span><br><span class="line"></span><br><span class="line">app.on(&#39;request&#39;, (req, res) &#x3D;&gt; &#123;</span><br><span class="line">	&#x2F;&#x2F; 获取用户的请求路径</span><br><span class="line">	let pathname &#x3D; url.parse(req.url).pathname;</span><br><span class="line"></span><br><span class="line">	pathname &#x3D; pathname &#x3D;&#x3D; &#39;&#x2F;&#39; ? &#39;&#x2F;default.html&#39; : pathname;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 将用户的请求路径转换为实际的服务器硬盘路径</span><br><span class="line">	let realPath &#x3D; path.join(__dirname, &#39;public&#39; + pathname);</span><br><span class="line"></span><br><span class="line">	let type &#x3D; mime.getType(realPath)</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 读取文件</span><br><span class="line">	fs.readFile(realPath, (error, result) &#x3D;&gt; &#123;</span><br><span class="line">		&#x2F;&#x2F; 如果文件读取失败</span><br><span class="line">		if (error !&#x3D; null) &#123;</span><br><span class="line">			res.writeHead(404, &#123;</span><br><span class="line">				&#39;content-type&#39;: &#39;text&#x2F;html;charset&#x3D;utf8&#39;</span><br><span class="line">			&#125;)</span><br><span class="line">			res.end(&#39;文件读取失败&#39;);</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		res.writeHead(200, &#123;</span><br><span class="line">			&#39;content-type&#39;: type</span><br><span class="line">		&#125;)</span><br><span class="line"></span><br><span class="line">		res.end(result);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(3000);</span><br><span class="line">console.log(&#39;服务器启动成功&#39;);</span><br></pre></td></tr></table></figure>

<p>动态资源：相同的请求地址不同的响应资源，这种资源就是动态资源。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">eg : http:&#x2F;&#x2F;www.baidu.cn&#x2F;article?id&#x3D;1</span><br><span class="line">	http:&#x2F;&#x2F;www.baidu.cn&#x2F;article?id&#x3D;2</span><br></pre></td></tr></table></figure>

<h3 id="3-node-js异步编程"><a href="#3-node-js异步编程" class="headerlink" title="3.node.js异步编程"></a>3.node.js异步编程</h3><h4 id="3-1-同步API和异步API"><a href="#3-1-同步API和异步API" class="headerlink" title="3.1 同步API和异步API"></a>3.1 同步API和异步API</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F; 路径拼接  返回值</span><br><span class="line">const public &#x3D; path.join(__dirname, &#39;public&#39;);</span><br><span class="line">&#x2F;&#x2F; 请求地址解析  返回值</span><br><span class="line">const urlObj &#x3D; url.parse(req.url);</span><br><span class="line">&#x2F;&#x2F; 读取文件  函数</span><br><span class="line">fs.readFile(&#39;.&#x2F;demo.txt&#39;, &#39;utf8&#39;, (err, result) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(result);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>同步API：只有当前API执行完成后，才能继续执行下一个API</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(&#39;before&#39;); </span><br><span class="line">console.log(&#39;after&#39;);</span><br></pre></td></tr></table></figure>

<p>异步API：当前API的执行不会阻塞后续代码的执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">console.log(&#39;before&#39;);</span><br><span class="line">setTimeout(</span><br><span class="line">() &#x3D;&gt; &#123; console.log(&#39;last&#39;);</span><br><span class="line">&#125;, 2000);</span><br><span class="line">console.log(&#39;after&#39;);</span><br></pre></td></tr></table></figure>

<h4 id="3-2-两者之间区别"><a href="#3-2-两者之间区别" class="headerlink" title="3.2 两者之间区别"></a>3.2 两者之间区别</h4><h5 id="​-3-2-1-获取返回值的方式不同"><a href="#​-3-2-1-获取返回值的方式不同" class="headerlink" title="​    3.2.1 获取返回值的方式不同"></a>​    3.2.1 获取返回值的方式不同</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 同步</span><br><span class="line">function sum (n1, n2) &#123; </span><br><span class="line">   return n1 + n2;</span><br><span class="line">&#125; </span><br><span class="line">const result &#x3D; sum (10, 20);</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 异步</span><br><span class="line">function getMsg () &#123; </span><br><span class="line">   setTimeout(function () &#123; </span><br><span class="line">       return &#123; msg: &#39;Hello Node.js&#39; &#125;</span><br><span class="line">   &#125;, 2000);</span><br><span class="line">   &#x2F;&#x2F; 原因:计时器需等待两秒,此期间 getMsg()函数返回的值是 undefined</span><br><span class="line">&#125;</span><br><span class="line">const msg &#x3D; getMsg ();</span><br><span class="line">&#x2F;&#x2F; 此代码得到的返回值是 Undefined</span><br></pre></td></tr></table></figure>

<p>====&gt; 上述异步 API 的值到底如何获取呢?</p>
<ul>
<li>回调函数<ul>
<li>自己定义函数让他人去调用</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; getData函数定义</span><br><span class="line">function getData (callback) &#123;&#125;</span><br><span class="line">&#x2F;&#x2F; getData函数调用</span><br><span class="line">getData (() &#x3D;&gt; &#123;&#125;);</span><br></pre></td></tr></table></figure>

<p>解决代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function getMsg (callback) &#123;</span><br><span class="line">	setTimeout(function () &#123;</span><br><span class="line">		callback(&#123;</span><br><span class="line">			msg: &#39;hello node.js&#39;</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;, 2000)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getMsg(function (data) &#123;</span><br><span class="line">	console.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h5 id="3-2-2-代码执行顺序不同"><a href="#3-2-2-代码执行顺序不同" class="headerlink" title="3.2.2 代码执行顺序不同"></a>3.2.2 代码执行顺序不同</h5><p>同步API : 从上到下依次执行，前面代码会阻塞后面代码的执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for (var i &#x3D; 0; i &lt; 100000; i++) &#123; </span><br><span class="line"> console.log(i);</span><br><span class="line">&#125;</span><br><span class="line">console.log(&#39;for循环后面的代码&#39;);</span><br></pre></td></tr></table></figure>

<p>异步API : 不会等待API执行完成后再向下执行代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">console.log(&#39;代码开始执行&#39;); </span><br><span class="line">setTimeout(() &#x3D;&gt; &#123; console.log(&#39;2秒后执行的代码&#39;)&#125;, 2000);</span><br><span class="line">setTimeout(() &#x3D;&gt; &#123; console.log(&#39;&quot;0秒&quot;后执行的代码&#39;)&#125;, 0); </span><br><span class="line">console.log(&#39;代码结束执行&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 代码执行结果如下 :</span><br><span class="line">&#x2F;&#x2F; 代码开始执行</span><br><span class="line">&#x2F;&#x2F; 代码结束执行</span><br><span class="line">&#x2F;&#x2F; 0s</span><br><span class="line">&#x2F;&#x2F; 2s</span><br></pre></td></tr></table></figure>

<p>异步API 代码执行顺序分析</p>
<p><img src="/2020/04/05/Node%20%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/D:%5COther%5CHexo%5CmyBlog%5Csource_posts%5CNode%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%5C%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E7%9A%84%E5%8E%9F%E7%90%86.png" alt></p>
<p>node.js 中的异步API</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(&#39;.&#x2F;demo.txt&#39;, (err, result) &#x3D;&gt; &#123;&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var server &#x3D; http.createServer();</span><br><span class="line">server.on(&#39;request&#39;, (req, res) &#x3D;&gt; &#123;&#125;);</span><br></pre></td></tr></table></figure>

<p>====&gt; 如果异步API后面代码的执行依赖当前异步API的执行结果，这个问题要怎么解决呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(&#39;.&#x2F;demo.txt&#39;, (err, result) &#x3D;&gt; &#123;&#125;);</span><br><span class="line">console.log(&#39;文件读取结果&#39;);</span><br></pre></td></tr></table></figure>

<p>====&gt;     // 需求 : 依次读取 ABC文件<br>        // 解决方案 :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const fs &#x3D; require(&#39;fs&#39;);</span><br><span class="line"></span><br><span class="line">fs.readFile(&#39;.&#x2F;1.txt&#39;, &#39;utf8&#39;, (err, result1) &#x3D;&gt; &#123;</span><br><span class="line">	console.log(result1);</span><br><span class="line">	fs.readFile(&#39;.&#x2F;2.txt&#39;, &#39;utf8&#39;, (err, result2) &#x3D;&gt; &#123;</span><br><span class="line">		console.log(result2);</span><br><span class="line">		fs.readFile(&#39;.&#x2F;3.txt&#39;, &#39;utf8&#39;, (err, result3) &#x3D;&gt; &#123;</span><br><span class="line">			console.log(result3);</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>===&gt; 存在的问题就是嵌套太多,可读性差!  于是为了解决回调地狱问题,引进了Promise</p>
<h4 id="3-3-Promise"><a href="#3-3-Promise" class="headerlink" title="3.3 Promise"></a>3.3 Promise</h4><ul>
<li>Promise出现的目的是解决Node.js异步编程中回调地狱的问题</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D;&gt; 基础代码</span><br><span class="line"></span><br><span class="line">let promise &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line"> setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">     if (true) &#123;</span><br><span class="line">         resolve(&#123;name: &#39;张三&#39;&#125;)</span><br><span class="line">     &#125;else &#123;</span><br><span class="line">         reject(&#39;失败了&#39;) </span><br><span class="line">     &#125; </span><br><span class="line"> &#125;, 2000);</span><br><span class="line">&#125;);</span><br><span class="line">promise.then(result &#x3D;&gt; console.log(result); &#x2F;&#x2F; &#123;name: &#39;张三&#39;&#125;)</span><br><span class="line">    .catch(error &#x3D;&gt; console.log(error); &#x2F;&#x2F; 失败了)</span><br></pre></td></tr></table></figure>

<p>​     ===&gt; 将异步 API 与错误的处理分离代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const fs &#x3D; require(&#39;fs&#39;);</span><br><span class="line">let promise &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">	fs.readFile(&#39;.&#x2F;100.txt&#39;, &#39;utf8&#39;, (err, result) &#x3D;&gt; &#123;</span><br><span class="line">		if (err !&#x3D; null) &#123;</span><br><span class="line">			reject(err);</span><br><span class="line">		&#125;else &#123;</span><br><span class="line">			resolve(result);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F; 链式编程</span><br><span class="line">promise.then((result) &#x3D;&gt; &#123;</span><br><span class="line">	 console.log(result);</span><br><span class="line">&#125;)</span><br><span class="line">.catch((err)&#x3D;&gt; &#123;</span><br><span class="line">	console.log(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>   ===&gt; Promise 改造回调地狱的代码 (依次读取 1.2.3文档)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">const fs &#x3D; require(&#39;fs&#39;);</span><br><span class="line">function p1 () &#123;</span><br><span class="line">	return new Promise ((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">		fs.readFile(&#39;.&#x2F;1.txt&#39;, &#39;utf8&#39;, (err, result) &#x3D;&gt; &#123;</span><br><span class="line">			resolve(result)</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br><span class="line">function p2 () &#123;</span><br><span class="line">	return new Promise ((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">		fs.readFile(&#39;.&#x2F;2.txt&#39;, &#39;utf8&#39;, (err, result) &#x3D;&gt; &#123;</span><br><span class="line">			resolve(result)</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br><span class="line">function p3 () &#123;</span><br><span class="line">	return new Promise ((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">		fs.readFile(&#39;.&#x2F;3.txt&#39;, &#39;utf8&#39;, (err, result) &#x3D;&gt; &#123;</span><br><span class="line">			resolve(result)</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br><span class="line">p1().then((r1)&#x3D;&gt; &#123;</span><br><span class="line">	console.log(r1);</span><br><span class="line">	return p2();</span><br><span class="line">&#125;)</span><br><span class="line">.then((r2)&#x3D;&gt; &#123;</span><br><span class="line">	console.log(r2);</span><br><span class="line">	return p3();</span><br><span class="line">&#125;)</span><br><span class="line">.then((r3) &#x3D;&gt; &#123;</span><br><span class="line">	console.log(r3)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="3-4异步函数"><a href="#3-4异步函数" class="headerlink" title="3.4异步函数"></a>3.4异步函数</h4><p>异步函数是异步编程语法的终极解决方案，将异步代码写成同步的形式，让代码不再有回调函数嵌套，使代码变得清晰明了,大大增加了可读性!</p>
<h5 id="3-4-1-异步函数的基础语法"><a href="#3-4-1-异步函数的基础语法" class="headerlink" title="3.4.1 异步函数的基础语法"></a>3.4.1 异步函数的基础语法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const fn &#x3D; async () &#x3D;&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">async function fn () &#123;&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="3-4-2-async-关键字"><a href="#3-4-2-async-关键字" class="headerlink" title="3.4.2 async 关键字"></a>3.4.2 async 关键字</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 1.在普通函数定义的前面加上async关键字 普通函数就变成了异步函数</span><br><span class="line">&#x2F;&#x2F; 2.异步函数默认的返回值是promise对象</span><br><span class="line">&#x2F;&#x2F; 3.在异步函数内部使用throw关键字进行错误的抛出</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; async function fn () &#123;</span><br><span class="line">&#x2F;&#x2F; 	throw &#39;发生了一些错误&#39;;</span><br><span class="line">&#x2F;&#x2F; 	return 123;</span><br><span class="line">&#x2F;&#x2F; &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; &#x2F;&#x2F; console.log(fn ())</span><br><span class="line">&#x2F;&#x2F; fn ().then(function (data) &#123;</span><br><span class="line">&#x2F;&#x2F; 	console.log(data);</span><br><span class="line">&#x2F;&#x2F; &#125;).catch(function (err)&#123;</span><br><span class="line">&#x2F;&#x2F; 	console.log(err);</span><br><span class="line">&#x2F;&#x2F; &#125;)</span><br><span class="line"></span><br><span class="line">&#x3D;&#x3D;&#x3D;&gt; 总结:</span><br><span class="line"></span><br><span class="line">1. 普通函数定义前加async关键字 普通函数变成异步函数</span><br><span class="line">2. 异步函数默认返回promise对象</span><br><span class="line">3. 在异步函数内部使用return关键字进行结果返回 结果会被包裹的promise对象中 return关键字代替了resolve方法</span><br><span class="line">4. 在异步函数内部使用throw关键字抛出程序异常</span><br><span class="line">5. 调用异步函数再链式调用then方法获取异步函数执行结果</span><br><span class="line">6. 调用异步函数再链式调用catch方法获取异步函数执行的错误信息</span><br></pre></td></tr></table></figure>

<h5 id="​3-4-3-await关键字"><a href="#​3-4-3-await关键字" class="headerlink" title="​3.4.3  await关键字"></a>​3.4.3  await关键字</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">async function p1 () &#123;</span><br><span class="line">	return &#39;p1&#39;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">async function p2 () &#123;</span><br><span class="line">	return &#39;p2&#39;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">async function p3 () &#123;</span><br><span class="line">	return &#39;p3&#39;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">async function run () &#123;</span><br><span class="line">	let r1 &#x3D; await p1()</span><br><span class="line">	let r2 &#x3D; await p2()</span><br><span class="line">	let r3 &#x3D; await p3()</span><br><span class="line">	console.log(r1)</span><br><span class="line">	console.log(r2)</span><br><span class="line">	console.log(r3)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run();</span><br><span class="line"></span><br><span class="line">&#x3D;&#x3D;&#x3D;&gt; 总结</span><br><span class="line"></span><br><span class="line">1. await关键字只能出现在异步函数中</span><br><span class="line">2. await promise await后面只能写promise对象 写其他类型的API是不不可以的</span><br><span class="line">3. await关键字可是暂停异步函数向下执行 直到promise返回结果</span><br></pre></td></tr></table></figure>

<h5 id="3-3-4-异步函数编程案例"><a href="#3-3-4-异步函数编程案例" class="headerlink" title="3.3.4 异步函数编程案例"></a>3.3.4 异步函数编程案例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const fs &#x3D; require(&#39;fs&#39;);</span><br><span class="line">&#x2F;&#x2F; 改造现有异步函数api 让其返回promise对象 从而支持异步函数语法</span><br><span class="line">const promisify &#x3D; require(&#39;util&#39;).promisify;</span><br><span class="line">&#x2F;&#x2F; 调用promisify方法改造现有异步API 让其返回promise对象</span><br><span class="line">const readFile &#x3D; promisify(fs.readFile);</span><br><span class="line"></span><br><span class="line">async function run () &#123;</span><br><span class="line">	let r1 &#x3D; await readFile(&#39;.&#x2F;1.txt&#39;, &#39;utf8&#39;)</span><br><span class="line">	let r2 &#x3D; await readFile(&#39;.&#x2F;2.txt&#39;, &#39;utf8&#39;)</span><br><span class="line">	let r3 &#x3D; await readFile(&#39;.&#x2F;3.txt&#39;, &#39;utf8&#39;)</span><br><span class="line">	console.log(r1)</span><br><span class="line">	console.log(r2)</span><br><span class="line">	console.log(r3)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run();</span><br></pre></td></tr></table></figure>

<p>调用 promisify 方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">promisify(fn, reverse)</span><br><span class="line">&#x3D;&#x3D;&#x3D;&gt;</span><br><span class="line">	fn &lt;function&gt; 有回调函数作为参数的函数</span><br><span class="line">	reverse &lt;Boolean&gt; 默认False。当fn的回调函数参数在前时(如setTimeout)，设为True。</span><br></pre></td></tr></table></figure>

<h3 id="4-node-js-的全局对象与全局变量"><a href="#4-node-js-的全局对象与全局变量" class="headerlink" title="4.node.js 的全局对象与全局变量"></a>4.node.js 的全局对象与全局变量</h3><h4 id="4-1-全局对象-global"><a href="#4-1-全局对象-global" class="headerlink" title="4.1 全局对象 global"></a>4.1 全局对象 global</h4><ul>
<li>参考网址 : <a href="https://www.runoob.com/nodejs/nodejs-global-object.html" target="_blank" rel="noopener">https://www.runoob.com/nodejs/nodejs-global-object.html</a></li>
<li>JavaScript 中有一个特殊的对象，称为全局对象（Global Object），它及其所有属性都可以在程序的任何地方访问，即全局变量。</li>
<li><strong>在浏览器 JavaScript 中，通常 window 是全局对象， 而 Node.js 中的全局对象是 global，所有全局变量（除了 global 本身以外）都是 global 对象的属性。</strong></li>
<li>在 Node.js 我们可以直接访问到 global 的属性，而不需要在应用中包含它。</li>
</ul>
<h4 id="4-2-全局对象与全局变量"><a href="#4-2-全局对象与全局变量" class="headerlink" title="4.2 全局对象与全局变量"></a>4.2 全局对象与全局变量</h4><ul>
<li>global 最根本的作用是作为全局变量的宿主。</li>
<li>按照 ECMAScript 的定义，满足以下条 件的变量是全局变量：<ul>
<li>在最外层定义的变量；</li>
<li>全局对象的属性；</li>
<li>隐式定义的变量（未定义直接赋值的变量）。</li>
</ul>
</li>
<li>当你定义一个全局变量时，这个变量同时也会成为全局对象的属性，反之亦然。要注意的是，在 Node.js 中你不可能在最外层定义变量，因为所有用户代码都是属于当前模块的， 而模块本身不是最外层上下文。</li>
</ul>
<p><strong>注意：</strong> <strong>最好不要使用 var 定义变量以避免引入全局变量，因为全局变量会污染命名空间，提高代码的耦合风险</strong>。</p>
</div><div class="post-copyright"><blockquote><p>原文作者: CodeHare</p><p>原文链接: <a href="https://baiqingru.github.io/2020/04/05/Node 异步编程/">https://baiqingru.github.io/2020/04/05/Node 异步编程/</a></p><p>版权声明: 转载请注明出处(必须保留作者署名及链接)</p></blockquote></div><div class="tags"></div><div class="post-share"><div class="social-share"><span>分享到:</span></div></div><div class="post-nav"><a href="/2020/04/11/mongodb%E5%AD%A6%E4%B9%A0/" class="pre">数据库概述及 mongoDB 学习</a><a href="/2020/04/04/%E5%88%9D%E8%AF%86Git/" class="next">初识 Git</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#node-js-异步编程"><span class="toc-text">node.js 异步编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-服务器端基本概念"><span class="toc-text">1.服务器端基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-网站的组成"><span class="toc-text">1.1 网站的组成</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-URL"><span class="toc-text">1.2 URL</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-客户端与服务器端"><span class="toc-text">1.3 客户端与服务器端</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-创建web服务器"><span class="toc-text">2.创建web服务器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-HTTP-协议"><span class="toc-text">2.1 HTTP 协议</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#超文本传输协议-http"><span class="toc-text">超文本传输协议 (http)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#报文"><span class="toc-text">报文</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#请求报文"><span class="toc-text">请求报文</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-响应报文"><span class="toc-text">2. 响应报文</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-请求参数"><span class="toc-text">3.请求参数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-路由"><span class="toc-text">2.2 路由</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-静态资源访问"><span class="toc-text">2.3 静态资源访问</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-node-js异步编程"><span class="toc-text">3.node.js异步编程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-同步API和异步API"><span class="toc-text">3.1 同步API和异步API</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-两者之间区别"><span class="toc-text">3.2 两者之间区别</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#​-3-2-1-获取返回值的方式不同"><span class="toc-text">​    3.2.1 获取返回值的方式不同</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-2-代码执行顺序不同"><span class="toc-text">3.2.2 代码执行顺序不同</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-Promise"><span class="toc-text">3.3 Promise</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4异步函数"><span class="toc-text">3.4异步函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-4-1-异步函数的基础语法"><span class="toc-text">3.4.1 异步函数的基础语法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-4-2-async-关键字"><span class="toc-text">3.4.2 async 关键字</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#​3-4-3-await关键字"><span class="toc-text">​3.4.3  await关键字</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-4-异步函数编程案例"><span class="toc-text">3.3.4 异步函数编程案例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-node-js-的全局对象与全局变量"><span class="toc-text">4.node.js 的全局对象与全局变量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-全局对象-global"><span class="toc-text">4.1 全局对象 global</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-全局对象与全局变量"><span class="toc-text">4.2 全局对象与全局变量</span></a></li></ol></li></ol></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/08/25/Promise%E5%8E%9F%E7%90%86/">Promise原理</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/10/Prettier/">Prettier</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/10/Fastclick%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/">Fastclick的简单使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/04/Eslint%E9%85%8D%E7%BD%AE/">Eslint配置</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E9%93%BE%E8%A1%A8/">数据结构与算法之链表</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E9%98%9F%E5%88%97/">数据结构与算法之队列</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E6%A0%88/">数据结构与算法之栈</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E6%95%B0%E7%BB%84/">数据结构与算法之数组</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/26/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/">线程机制与事件机制</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/25/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E8%BF%B0%E5%8F%8A%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%AD%A6%E4%B9%A0/">数据库概述及环境搭建学习</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/node-js/" style="font-size: 15px;">node.js</a> <a href="/tags/JavaScript/" style="font-size: 15px;">JavaScript</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3/" style="font-size: 15px;">数据库简单了解</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" style="font-size: 15px;">数据结构与算法</a> <a href="/tags/%E5%85%B6%E4%BD%99/" style="font-size: 15px;">其余</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3/" style="font-size: 15px;">数据库的简单了解</a> <a href="/tags/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/" style="font-size: 15px;">配置文件</a> <a href="/tags/ES6/" style="font-size: 15px;">ES6</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/">2020</a><span class="archive-list-count">23</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">网站地图</a> |  <a href="/atom.xml">订阅本站</a> |  <a href="/about/">联系博主</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">CodeHare.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/" target="_blank" rel="noopener"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.5"></script><div id="fullscreen-img" class="hide"><span class="close"></span></div><script type="text/javascript" src="/js/imgview.js?v=2.0.5" async></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.5" async></script><link rel="stylesheet" type="text/css" href="/share/css/share.css"><script type="text/javascript" src="/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/share/js/qrcode.js" charset="utf-8"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>